name: Demo Build & Upload

on:
  push:
    branches: [ main, develop ]

env:
  NEXUS_URL: http://127.0.0.1:8081
  NEXUS_REPOSITORY_URL: http://127.0.0.1:8081/repository/JuiceShopMavenDemo
  NEXUS_USERNAME: admin
  NEXUS_PASSWORD: ${{ secrets.NEXUS_PASSWORD }}
  NEXUS_GROUP_ID: com.example.vulnerable
  NEXUS_ARTIFACT_ID: vulnerable-app
  APP_NAME: vulnerable-app
  ARTIFACT_VERSION: ${{ github.run_number }}
  SONAR_HOST_URL: http://localhost:9000

jobs:
  build:
    # For local Nexus uploads, using: self-hosted runner
    # Setup: See .github/SELF_HOSTED_RUNNER_SETUP.md
    runs-on: self-hosted
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.0'
          extensions: pdo, pdo_sqlite, gd

      - name: SonarQube Scan
        run: |
          Write-Host "Starting SonarQube analysis..." -ForegroundColor Cyan
          
          # Download SonarScanner if not present
          $scannerPath = "C:\sonar-scanner"
          if (-not (Test-Path "$scannerPath\bin\sonar-scanner.bat")) {
            Write-Host "Downloading SonarScanner..." -ForegroundColor Yellow
            $scannerUrl = "https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-windows.zip"
            $zipPath = "$env:TEMP\sonar-scanner.zip"
            Invoke-WebRequest -Uri $scannerUrl -OutFile $zipPath -UseBasicParsing
            Expand-Archive -Path $zipPath -DestinationPath "C:\" -Force
            Move-Item "C:\sonar-scanner-5.0.1.3006-windows" $scannerPath -Force
            Write-Host "✓ SonarScanner installed" -ForegroundColor Green
          }
          
          # Run SonarQube scan
          $sonarArgs = @(
            "-Dsonar.projectKey=vulnerable-demo-app",
            "-Dsonar.sources=.",
            "-Dsonar.host.url=http://localhost:9000",
            "-Dsonar.token=${{ secrets.SONAR_TOKEN }}",
            "-Dsonar.projectName=Vulnerable Demo Application",
            "-Dsonar.projectVersion=${{ env.ARTIFACT_VERSION }}"
          )
          
          & "$scannerPath\bin\sonar-scanner.bat" @sonarArgs
          
          Write-Host "✓ SonarQube analysis complete" -ForegroundColor Green
          Write-Host "View results: http://localhost:9000/dashboard?id=vulnerable-demo-app" -ForegroundColor Cyan
          
          # Save SonarQube report locally
          $localReportPath = "C:\Users\admin\Desktop\Reports\Pipeline Generated Reports"
          if (-not (Test-Path $localReportPath)) {
            New-Item -Path $localReportPath -ItemType Directory -Force | Out-Null
          }
          
          # Create SonarQube report summary
          $sonarReportFile = "$localReportPath\SonarQube-Report-Build-${{ github.run_number }}.txt"
          @"
SonarQube Analysis Report
=========================
Build Number: ${{ github.run_number }}
Project: Vulnerable Demo Application
Version: ${{ env.ARTIFACT_VERSION }}
Scan Date: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")
Dashboard URL: http://localhost:9000/dashboard?id=vulnerable-demo-app

Status: Analysis Complete
"@ | Out-File -FilePath $sonarReportFile -Encoding UTF8
          
          Write-Host "✓ SonarQube report saved: $sonarReportFile" -ForegroundColor Green
        shell: pwsh
        continue-on-error: true

      - name: Create ZIP Artifact
        run: |
          $zipPath = "${{ github.workspace }}\${{ env.APP_NAME }}-${{ env.ARTIFACT_VERSION }}.zip"
          $excludePatterns = @('\.git', '\.github', '\.gitignore', 'node_modules', 'vendor', '*.zip')
          
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          
          $sourceDir = "${{ github.workspace }}"
          $zip = [System.IO.Compression.ZipFile]::Open($zipPath, 'Create')
          
          Get-ChildItem -Path $sourceDir -Recurse -File | Where-Object {
            $file = $_
            -not ($excludePatterns | Where-Object { $file.FullName -like "*$_*" })
          } | ForEach-Object {
            $entryPath = $_.FullName.Substring($sourceDir.Length).TrimStart('\')
            [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($zip, $_.FullName, $entryPath) | Out-Null
          }
          
          $zip.Dispose()
          $zipSize = "{0:F2}" -f ((Get-Item $zipPath).Length / 1MB)
          Write-Host "✓ ZIP created: $zipSize MB"
        shell: pwsh

      - name: Upload to GitHub Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-build-${{ env.ARTIFACT_VERSION }}
          path: ${{ github.workspace }}\${{ env.APP_NAME }}-${{ env.ARTIFACT_VERSION }}.zip
          retention-days: 30

      - name: Upload to Nexus
        run: |
          $zipFile = "${{ github.workspace }}\${{ env.APP_NAME }}-${{ env.ARTIFACT_VERSION }}.zip"
          $groupPath = "${{ env.NEXUS_GROUP_ID }}".Replace(".", "/")
          $nexusUrl = "${{ env.NEXUS_REPOSITORY_URL }}/$groupPath/${{ env.NEXUS_ARTIFACT_ID }}/${{ env.ARTIFACT_VERSION }}/${{ env.NEXUS_ARTIFACT_ID }}-${{ env.ARTIFACT_VERSION }}.zip"
          
          Write-Host "Uploading to Nexus..."
          
          $base64Creds = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("${{ env.NEXUS_USERNAME }}:${{ env.NEXUS_PASSWORD }}"))
          $headers = @{
            "Authorization" = "Basic $base64Creds"
            "Content-Type" = "application/zip"
          }
          
          try {
            $response = Invoke-WebRequest -Uri $nexusUrl -Method PUT -InFile $zipFile -Headers $headers -UseBasicParsing
            Write-Host "✓ Uploaded to Nexus (Status: $($response.StatusCode))"
          } catch {
            Write-Host "⚠ Warning: Nexus upload failed - $($_.Exception.Message)"
            Write-Host "ℹ Note: If using windows-latest runner, Nexus is not accessible."
            Write-Host "ℹ Solution: Setup self-hosted runner on your VM (see .github/SELF_HOSTED_RUNNER_SETUP.md)"
          }
        shell: pwsh
        continue-on-error: true

      - name: Download from Nexus
        run: |
          Write-Host "Downloading latest artifact from Nexus..."
          
          $groupPath = "${{ env.NEXUS_GROUP_ID }}".Replace(".", "/")
          $nexusUrl = "${{ env.NEXUS_REPOSITORY_URL }}/$groupPath/${{ env.NEXUS_ARTIFACT_ID }}/${{ env.ARTIFACT_VERSION }}/${{ env.NEXUS_ARTIFACT_ID }}-${{ env.ARTIFACT_VERSION }}.zip"
          $downloadPath = "${{ github.workspace }}\downloaded-artifact.zip"
          
          $base64Creds = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes("${{ env.NEXUS_USERNAME }}:${{ env.NEXUS_PASSWORD }}"))
          $headers = @{
            "Authorization" = "Basic $base64Creds"
          }
          
          try {
            Invoke-WebRequest -Uri $nexusUrl -OutFile $downloadPath -Headers $headers -UseBasicParsing
            $downloadSize = "{0:F2}" -f ((Get-Item $downloadPath).Length / 1MB)
            Write-Host "✓ Downloaded from Nexus: $downloadSize MB"
          } catch {
            Write-Host "✗ Failed to download from Nexus: $($_.Exception.Message)"
            exit 1
          }
        shell: pwsh

      - name: Deploy to IIS
        run: |
          Write-Host "Deploying to IIS..."
          
          $iisPath = "C:\inetpub\wwwroot\JuiceShop\${{ env.APP_NAME }}"
          $zipFile = "${{ github.workspace }}\downloaded-artifact.zip"
          
          # Create or clean deployment directory
          if (Test-Path $iisPath) {
            Write-Host "Cleaning existing deployment directory..."
            Remove-Item -Path $iisPath\* -Recurse -Force
          } else {
            Write-Host "Creating deployment directory..."
            New-Item -Path $iisPath -ItemType Directory -Force | Out-Null
          }
          
          # Extract ZIP to IIS
          Write-Host "Extracting application files..."
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::ExtractToDirectory($zipFile, $iisPath)
          
          $fileCount = (Get-ChildItem -Path $iisPath -Recurse -File).Count
          Write-Host "✓ Deployed $fileCount files to IIS"
          Write-Host "✓ Location: $iisPath"
        shell: pwsh

      - name: Restart IIS
        run: |
          Write-Host "Restarting IIS Application Pool..."
          
          try {
            # Restart the application pool (usually DefaultAppPool or specific pool)
            Import-Module WebAdministration
            
            # Find the app pool for this application
            $appPoolName = "DefaultAppPool"
            
            if (Get-WebAppPoolState -Name $appPoolName) {
              Restart-WebAppPool -Name $appPoolName
              Write-Host "✓ IIS Application Pool '$appPoolName' restarted"
              Start-Sleep -Seconds 2
            }
            
            # Alternative: Reset IIS completely
            Write-Host "Resetting IIS..."
            iisreset /restart /noforce
            Write-Host "✓ IIS restarted successfully"
            
          } catch {
            Write-Host "⚠ Warning: IIS restart encountered an issue - $($_.Exception.Message)"
          }
        shell: pwsh
        continue-on-error: true

      - name: Verify Deployment
        run: |
          Write-Host "Verifying deployment..."
          
          $appUrl = "http://localhost/vulnerable-app/"
          $iisPath = "C:\inetpub\wwwroot\JuiceShop\${{ env.APP_NAME }}"
          
          # Check files exist
          if (Test-Path "$iisPath\index.php") {
            Write-Host "✓ Application files deployed"
          } else {
            Write-Host "✗ index.php not found"
          }
          
          # Try to access application
          try {
            Start-Sleep -Seconds 2
            $response = Invoke-WebRequest -Uri $appUrl -UseBasicParsing -TimeoutSec 5
            if ($response.StatusCode -eq 200) {
              Write-Host "✓ Application is accessible at $appUrl"
            }
          } catch {
            Write-Host "⚠ Application may not be accessible yet: $($_.Exception.Message)"
            Write-Host "ℹ Check manually at: $appUrl"
          }
        shell: pwsh
        continue-on-error: true

      - name: OWASP ZAP Security Scan
        run: |
          Write-Host "Starting OWASP ZAP security scan..." -ForegroundColor Cyan
          
          $zapPath = "C:\Program Files\ZAP\Zed Attack Proxy"
          $targetUrl = "http://localhost/vulnerable-app/"
          $reportPath = "${{ github.workspace }}\zap-report.html"
          $jsonReportPath = "${{ github.workspace }}\zap-report.json"
          
          # Verify application is running
          try {
            $response = Invoke-WebRequest -Uri $targetUrl -UseBasicParsing -TimeoutSec 5
            Write-Host "✓ Application is accessible for scanning" -ForegroundColor Green
          } catch {
            Write-Host "⚠ Warning: Application not accessible, scan may fail" -ForegroundColor Yellow
          }
          
          Write-Host "Running ZAP baseline scan..." -ForegroundColor Cyan
          Write-Host "Target: $targetUrl" -ForegroundColor White
          
          # Run ZAP baseline scan
          # Using baseline scan for quick security checks (suitable for CI/CD)
          $zapCmd = "python"
          $zapScript = "$zapPath\zap-baseline.py"
          
          # Check if Python script exists
          if (Test-Path $zapScript) {
            & $zapCmd $zapScript -t $targetUrl -r $reportPath -J $jsonReportPath -I
            Write-Host "✓ ZAP scan completed" -ForegroundColor Green
          } else {
            # Fallback to running ZAP in CLI mode
            Write-Host "Running ZAP in CLI mode..." -ForegroundColor Yellow
            
            $zapApiKey = "changeme123"
            $zapPort = 8090
            
            # Start ZAP in daemon mode
            Start-Process -FilePath "$zapPath\zap.bat" -ArgumentList "-daemon -port $zapPort -config api.key=$zapApiKey" -WindowStyle Hidden
            Start-Sleep -Seconds 15
            
            # Spider the application
            $spiderUrl = "http://localhost:${zapPort}/JSON/spider/action/scan/?url=$targetUrl&apikey=$zapApiKey"
            Invoke-RestMethod -Uri $spiderUrl -Method Get
            Start-Sleep -Seconds 10
            
            # Run active scan
            $scanUrl = "http://localhost:${zapPort}/JSON/ascan/action/scan/?url=$targetUrl&apikey=$zapApiKey"
            Invoke-RestMethod -Uri $scanUrl -Method Get
            Start-Sleep -Seconds 20
            
            # Generate HTML report
            $reportUrl = "http://localhost:${zapPort}/OTHER/core/other/htmlreport/?apikey=$zapApiKey"
            $report = Invoke-RestMethod -Uri $reportUrl -Method Get
            $report | Out-File -FilePath $reportPath -Encoding UTF8
            
            Write-Host "✓ ZAP scan completed" -ForegroundColor Green
            
            # Stop ZAP
            Stop-Process -Name "java" -ErrorAction SilentlyContinue
          }
          
          Write-Host "Report saved: $reportPath" -ForegroundColor Cyan
          
          # Save ZAP reports locally to desktop
          $localReportPath = "C:\Users\admin\Desktop\Reports\Pipeline Generated Reports"
          if (-not (Test-Path $localReportPath)) {
            New-Item -Path $localReportPath -ItemType Directory -Force | Out-Null
          }
          
          # Copy reports to desktop with build number
          if (Test-Path $reportPath) {
            Copy-Item $reportPath -Destination "$localReportPath\ZAP-Report-Build-${{ github.run_number }}.html" -Force
            Write-Host "✓ ZAP HTML report saved: $localReportPath\ZAP-Report-Build-${{ github.run_number }}.html" -ForegroundColor Green
          }
          
          if (Test-Path $jsonReportPath) {
            Copy-Item $jsonReportPath -Destination "$localReportPath\ZAP-Report-Build-${{ github.run_number }}.json" -Force
            Write-Host "✓ ZAP JSON report saved: $localReportPath\ZAP-Report-Build-${{ github.run_number }}.json" -ForegroundColor Green
          }
          
          Write-Host ""
        shell: pwsh
        continue-on-error: true

      - name: Upload ZAP Report
        uses: actions/upload-artifact@v4
        with:
          name: zap-security-report-${{ env.ARTIFACT_VERSION }}
          path: |
            ${{ github.workspace }}\zap-report.html
            ${{ github.workspace }}\zap-report.json
          retention-days: 30
        continue-on-error: true

      - name: Deployment Summary
        run: |
          Write-Host ""
          Write-Host "========================================" -ForegroundColor Green
          Write-Host "✓ Deployment Completed" -ForegroundColor Green
          Write-Host "========================================" -ForegroundColor Green
          Write-Host ""
          Write-Host "Build #: ${{ github.run_number }}"
          Write-Host "Artifact: ${{ env.APP_NAME }}-${{ env.ARTIFACT_VERSION }}.zip"
          Write-Host "Deployed to: C:\inetpub\wwwroot\JuiceShop\${{ env.APP_NAME }}"
          Write-Host "Application URL: http://localhost/vulnerable-app/"
          Write-Host "Nexus URL: ${{ env.NEXUS_REPOSITORY_URL }}"
          Write-Host ""
          Write-Host "Security Scanning:" -ForegroundColor Cyan
          Write-Host "✓ SonarQube: http://localhost:9000/dashboard?id=vulnerable-demo-app"
          Write-Host "✓ OWASP ZAP: Check artifacts for security reports"
          Write-Host ""
          Write-Host "Next Steps:"
          Write-Host "1. Access app at http://localhost/vulnerable-app/"
          Write-Host "2. View artifact in Nexus at http://127.0.0.1:8081/"
          Write-Host "3. Review SonarQube analysis at http://localhost:9000/"
          Write-Host "4. Download ZAP security reports from GitHub Actions artifacts"
          Write-Host ""
        shell: pwsh
